/**
    2.算法

    2.4 算法的定义
        算法是解决特定问题求解步骤的描述, 在计算机中表现为指令的有限序列, 并且每条指令表示一个或多个操作.

        算法定义中, 提到了指令, 指令能被人或机器等计算装置执行.它可以是计算机指令, 也可以是我们平时的语言文字.
        为了解决某个或某类问题, 需要把指令表示成一定的操作序列, 操作序列包括一组操作, 每一个操作都完成特定的功能, 这就是算法了.

    2.5 算法的特性
        算法具有五个基本特性: 输入, 输出, 有穷性, 确定性和可行性.

        2.5.1 输入输出
            算法具有零个或多个输入.
            算法至少有一个或多个输出.

        2.5.2 有穷性
            有穷性: 指算法在执行有限的步骤之后, 自动结束而不会出现无限循环, 并且每一个步骤在可接受的时间内完成.

        2.5.3 确定性
            确定性: 算法的每一步骤都具有确定的含义, 不会出现二义性.

        2.5.4 可行性
            可行性: 算法的每一步都必须是可行的, 也就是说, 每一步都能够通过执行有限次数完成.

    2.6 算法设计的要求
        2.6.1 正确性
            正确性: 算法的正确性是指算法应该具有输入, 输出和加工处理无歧义性, 能正确反映问题的需求, 能够得到问题的正确答案.

            但是算法的"正确"通常在用法上有很大的差别, 大体分为以下四个层次.
            1. 算法程序没有语法错误.
            2. 算法程序对于合法的输入数据能够产生满足要求的输出结果.
            3. 算法程序对于非法的输入数据得出满足规格说明的结果.
            4. 算法程序对于精心选择的, 甚至刁难的测试数据都有满足要求的输出结果.

        2.6.2 可读性
            可读性: 算法设计的另一目的是为了便于阅读, 理解和交流.

        2.6.3 健壮性
            健壮性: 当输入数据不合法时, 算法也能做出相关处理, 而不是产生异常或莫名其妙的结果.

        2.6.4 时间效率高和存储量低
            设计算法应该尽量时间效率高和存储量低的需求.

    2.7 算法效率的度量方法
        2.7.1 事后统计方法
            事后统计方法: 这种方法主要是通过设计好的测试程序和数据, 利用计算机计时器对不同算法编制的程序的运行时间进行比较, 从而确定算法效率的高低.

        2.7.2 事前分析估算方法
            事前分析估算方法: 在计算机程序编制前, 依据统计方法对算法进行估算.

            一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:
            1. 算法采用的策略, 方法.
            2. 编译产生的代码质量.
            3. 问题的输入规模.
            4. 机器执行指令的速度.
            第 1 条当然是算法好坏的根本, 第 2 条要由软件来支持, 第 4 条要看硬件性能.

            抛开这些与计算机硬件, 软件有关的因素,

            一个程序的运行时间, 依赖于算法的好坏和问题的输入规模.
            所谓问题的输入规模是指输入量的多少.

            不计那些循环索引的递增和循环终止条件, 变量声明, 打印结果等操作,
            最终, 在分析程序的运行时间时, 最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤.

    2.8 函数的渐近增长
        函数的渐近增长: 给定两个函数 f(n) 和 g(n), 如果存在一个整数N, 使得对于所有的 n > N, f(n) 总是比 g(n) 大, 那么, 我们说 f(n) 的增长渐近快于 g(n).

        我们可以忽略这些加法常数. ( 2n + 3, 3n + 1 )

        与最高次项相乘的常数并不重要. ( 4n + 8, 2n^2 + 1 )

        最高次项的指数大的, 函数随 n 的增长, 结果也会变得增长特别快. ( 2n^2 + 3n + 1, 2n^3 + 3n + 1 )

        判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略, 而更应该关注主项(最高阶项)的阶数. ( 2n^2, 3n + 1, 2n^2 + 3n + 1 )

        某个算法, 随着 n 的增大, 它会越来越优于另一算法, 或者越来越差于另一算法.

    2.9 算法时间复杂度
        2.9.1 算法时间复杂度定义
            在进行算法分析时, 语句总的执行次数 T(n) 是关于问题规模 n 的函数, 进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级.
            算法的时间复杂度, 也就是算法的时间量度, 记作: T(n) = O(f(n)).
            它表示随问题规模 n 的增大, 算法执行时间的增长率和 f(n) 的增长率相同, 称作算法的渐近时间复杂度, 简称为时间复杂度.
            其中 f(n) 是问题规模 n 的某个函数.

        2.9.2 推导大 O 阶的方法
            推导大 O 阶:
            1. 用常数 1 取代运行时间中的所有加法常数.
            2. 在修改运行次数的函数中, 只保留最高阶项.
            3. 如果最高阶项存在且不是 1, 则去除这个项相乘的常数.
            得到的结果就是大 O 阶.

            理解大 O 推导不算难, 难的是对数列的一些相关运算, 这更多的是考察你的数学知识和能力.

        2.9.3 常数阶 O(1)

        2.9.4 线性阶 O(n)
            我们要分析算法的复杂度, 关键就是要分析循环结构的运行情况.

        2.9.5 对数阶 O(log n)

        2.9.6 平方阶 O(n^2)

    2.10 常见的时间复杂度
        O(1) < O(log n) < O(n) < O(n * log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

    2.11 最坏情况与平均情况
        最坏情况运行时间是一种保证, 那就是运行时间不会再坏了.
        在应用中, 这是一种最重要的需求, 通常, 除非特别指定, 我们提到的运行时间都是最坏情况的运行时间.

        平均运行时间时所有情况中最有意义的, 因为它是期望的运行时间.

        一般在没有特殊说明的情况下, 都是指最坏时间复杂度.

    2.12 算法空间复杂度
        算法的空间复杂度通过计算算法所需的存储空间实现, 算法空间复杂度的计算公式记作: S(n) = O(f(n)),
        其中, n 为问题的规模, f(n) 为语句关于 n 所占存储空间的函数.
 */