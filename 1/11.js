/**
  * @description: 接下来如何做
  */

/**
  * 树
  * 如果你对数据库或高级数据结构感兴趣，请研究如下数据结构：B树，红黑树，堆，伸展树。
  */

/**
  * 反向索引
  * 如果你对搜索感兴趣，从反向索引着手研究是不错的选择。
  */

/**
  * 傅里叶变换
  * 绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。
  * Better Explained是一个杰出的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：
      给它一杯冰沙，它能告诉你其中包含哪些成分。
      换言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来。
  * 这种理念虽然简单，应用却极其广泛。
  * 例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。
  * 傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。为此，首先需要将音频文件分解为音符。
  * 傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理！
  * 数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅里叶变换还被用来地震预测和DNA分析。
  * 使用傅里叶变换可创建类似于Shazam这样的音乐识别软件。傅里叶变换的用途极其广泛，你遇到它的可能性极高！
  */

/**
  * 并行算法
  * 我们身处一个处理器速度越来越快的时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。
  * 但这个时代已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。
  * 为提高算法的速度，你需要让它们能够在多个内核中并行地执行！
  *
  * 来看一个简单的例子。
  * 在最佳情况下，排序算法的速度大致为O(n log n)。
  * 众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)！
  * 对数组进行排序时，快速排序的并行版本所需的时间为O(n)。
  *
  * 并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。
  * 有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。
      并行性管理开销。
        假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？
        如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。
      负载均衡。
        假设你需要完成10个任务，因此你给每个内核都分配5个任务。
        但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。
        这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！
        你如何均匀地分配工作，让两个内核都一样忙呢？
  *
  * 要改善性能和可扩展性，并行算法可能是不错的选择！
  */

/**
  * MapReduce
  * 有一种特殊的并行算法正越来越流行，它就是分布式算法。
  * 在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？
  * 在这种情况下，可让算法在多台计算机上运行。
  * MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。
  *
  * 分布式算法为何很有用
  * 假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。
  * 在这种情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。
  * 相反，你需要通过Hadoop来使用MapReduce！
  *
  * 又假设你需要处理一个很长的清单，其中包含100万个职位，而每个职位处理起来需要10秒。
  * 如果使用一台计算机来处理，将耗时数月！如果使用100台计算机来处理，可能几天就能完工。
  * 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。
  *
  * 映射函数
  * 映射是将一个数组转换为另一个数组。
  * 映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。
  * 如果有100台计算机，而map能够自动将工作分配给这些计算机去完成就好了。
  * 这样就可同时下载100个页面，下载速度将快得多！这就是MapReduce中“映射”部分基于的理念。
  *
  * 归并函数
  * 归并是将一个数组转换为一个元素。
  *
  * MapReduce使用这两个简单概念在多台计算机上执行数据查询。
  * 数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。
  */

/**
  * 布隆过滤器和HyperLogLog
  * 面临海量数据，你需要创造性的解决方案！
  *
  * 布隆过滤器提供了解决之道。
  * 布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。
  * 为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。
  * 使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。
      可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。
      不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。
  * 布隆过滤器的优点在于占用的存储空间很少。
  * 使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。
  * 布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。
  * 对bit.ly而言，这样说完全可行：“我们认为这个网站可能是恶意的，请倍加小心。”
  *
  * HyperLogLog
  * HyperLogLog是一种类似于布隆过滤器的算法。
  * 如果Google要计算用户执行的不同搜索的数量，或者Amazon要计算当天用户浏览的不同商品的数量，要回答这些问题，需要耗用大量的空间！
  * 对Google来说，必须有一个日志，其中包含用户执行的不同搜索。
  * 有用户执行搜索时，Google必须判断该搜索是否包含在日志中：
      如果答案是否定的，就必须将其加入到日志中。即便只记录一天的搜索，这种日志也大得不得了！
  * HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。
  * 面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！
  */

/**
  * SHA 算法
  * 另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。
  * 给定一个字符串，SHA返回其散列值。
  * 这里的术语有点令人迷惑。SHA是一个散列函数，它生成一个散列值——一个较短的字符串。
  * 用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。
  * 对于每个不同的字符串，SHA生成的散列值都不同。
  * 你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。
  *
  * 假设你有一个4 GB的文件，并要检查朋友是否也有这个大型文件。
  * 为此，你不用通过电子邮件将这个大型文件发送给朋友，而可计算它们的SHA散列值，再对结果进行比较。
  * SHA还让你能在不知道原始字符串的情况下对其进行比较。
  *
  * 例如，假设Gmail遭到攻击，攻击者窃取了所有的密码！你的密码暴露了吗？
  * 没有，因为Google存储的并非密码，而是密码的SHA散列值！
  * 你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。
  * Google只是比较散列值，因此不必存储你的密码！
  * SHA被广泛用于计算密码的散列值。
  * 这种散列算法是单向的。你可根据字符串计算出散列值。但你无法根据散列值推断出原始字符串。
  * 这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码转换为散列值，但反过来不行。
  * 当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。
  *
  * SHA还有一个重要特征，那就是局部不敏感的。
  *
  * 假设你有一个字符串，并计算了其散列值。
  * 如果你修改其中的一个字符，再计算其散列值，结果将截然不同！
  * 这很好，让攻击者无法通过比较散列值是否类似来破解密码。
  *
  * 有时候，你希望结果相反，即希望散列函数是局部敏感的。
  * 在这种情况下，可使用Simhash。
  * 如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。
  * 这让你能够通过比较散列值来判断两个字符串的相似程度，这很有用！
      Google使用Simhash来判断网页是否已搜集。
      老师可以使用Simhash来判断学生的论文是否是从网上抄的。
      Scribd允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容！这个网站可使用Simhash来检查上传的内容是否与小说《哈利·波特》类似，如果类似，就自动拒绝。
  * 需要检查两项内容的相似程度时，Simhash很有用。
  */

/**
  * Diffie-Hellman 密钥交换
  * 这里有必要提一提Diffie-Hellman算法，它以优雅的方式解决了一个古老的问题：如何对消息进行加密，以便只有收件人才能看懂呢？
  * Diffie-Hellman算法解决了如下两个问题。
      双方无需知道加密算法。他们不必会面协商要使用的加密算法。
      要破解加密的消息比登天还难。
  * Diffie-Hellman使用两个密钥：公钥和私钥。
  * 顾名思义，公钥就是公开的，可将其发布到网站上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。
  * 有人要向你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。
  * 只要只有你知道私钥，就只有你才能解密消息！
  *
  * Diffie-Hellman算法及其替代者RSA依然被广泛使用。
  * 如果你对加密感兴趣，先着手研究Diffie-Hellman算法是不错的选择：它既优雅又不难理解。
  */

/**
  * 线性规划
  * 线性规划用于在给定约束条件下最大限度地改善指定的指标。
  *
  * 例如，假设你所在的公司生产两种产品：衬衫和手提袋。
  * 衬衫每件利润2美元，需要消耗1米布料和5粒扣子；
  * 手提袋每个利润3美元，需要消耗2米布料和2粒扣子。
  * 你有11米布料和20粒扣子，为最大限度地提高利润，该生产多少件衬衫、多少个手提袋呢？
  * 在这个例子中，目标是利润最大化，而约束条件是拥有的原材料数量。
  *
  * 再举一个例子。你是个政客，要尽可能多地获得支持票。
  * 你经过研究发现，平均而言，对于每张支持票，在旧金山需要付出1小时的劳动（宣传、研究等）和2美元的开销，而在芝加哥需要付出1.5小时的劳动和1美元的开销。
  * 在旧金山和芝加哥，你至少需要分别获得500和300张支持票。你有50天的时间，总预算为1500美元。
  * 请问你最多可从这两个地方获得多少支持票？
  * 这里的目标是支持票数最大化，而约束条件是时间和预算。
  *
  * 所有的图算法都可使用线性规划来实现。
  * 线性规划是一个宽泛得多的框架，图问题只是其中的一个子集。
  *
  * 线性规划使用Simplex算法，这个算法很复杂，因此本书没有介绍。如果你对最优化感兴趣，就研究研究线性规划吧！
  */